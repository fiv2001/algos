#include <bits/stdc++.h>
#define pb push_back
#define pll pair <ll, ll>
#define mp make_pair
#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
// #pragma optimize("TKACHENKO-GORYACHENKO")
#define x first
#define y second
// #pragma GCC optimize("O3")
#define plll pair <pair <ll, ll>, ll>
#define pllll pair <pair <ll, ll>, pair <ll, ll> >
#define psl pair <string, ll>
#define all(a) a.begin(), a.end()
// #pragma comment(linker, "/stack:2000000000")

typedef int ll;

typedef long double ld;

using namespace std;

const ll maxn = 4e5;
const ll maxc = 30;

ll n, m, k;

ll D[maxn];

// ll stupid(string s) {
// 	ll q, w;
// 	set <string> S;
//  	for (q = 0; q < s.length(); q++) {
// 		for (w = q; w < s.length(); w++) {
// 			string ds = s.substr(q, w - q + 1);
// 			// cout << ds << endl;
// 			S.insert(ds);
// 		}
// 	}
// 	return S.size();
// }

struct vertex {
	vector <ll> to;
	ll suf = -1, p = -1;
	vertex() {
		to.resize(maxc, -1);
	}
};

struct pistol {
	vector <vertex> V;
	ll last = 0;
	pistol() {
		V.resize(1);
	}
	void add(ll c) {
		ll q;
		vertex nw;
		V.pb(nw);
		ll i = last;
		last = V.size() - 1;
		V.back().p = last;
		ll a, b;
		while (1) {
			if (V[i].to[c] != -1) {
				a = i;
				b = V[i].to[c];
				break;
			}
			// cout << "I " << i << endl;
			V[i].to[c] = V.size() - 1;
			if (V[i].suf == -1) {
				// V.back().p = i;
				V.back().suf = 0;
				// cout << "CASE 1" << endl;
				return;
			}
			// V.back().p = i;
			i = V[i].suf;
		}
		// cout << "A B " << a << " " << b << endl;
		if (V[b].p == a) {
			// V.back().p = a;
			V.back().suf = b;
			// cout << "CASE 2" << endl;
			return;
		}
		// cout << "CASE 3" << endl;
		V.back().p = a;
		ll d = V.size();
		V.back().suf = d;
		V.pb(nw);
		i = a;
		while (i != -1) {
			if (V[i].to[c] != b) {
				break;
			}
			V[i].to[c] = d;
			i = V[i].suf;
		}
		for (q = 0; q < maxc; q++) {
			V[d].to[q] = V[b].to[q];
		}
		V[d].p = a;
		V[d].suf = V[b].suf;
		V[b].suf = d;
	}
	// void debug()
};

pistol p;

vector <ll> V1[maxn];
// vector <vertex> V1;

bool used[maxn];

void dfs(ll v) {
	assert(used[v] == false);
	cout << v << ' ' << 1 << endl;
	// cout << v << " " << h << endl;
	if (D[v] != 0) {
		return;
	}
	used[v] = 1;
	// cout << 2 << endl;
	D[v] = 1;
	for (auto v1 : V1[v]) {
		//assert(used[v1] == bool(D[v1]));
		if (v1 != -1 && !used[v1]) {
			cout << 6 << endl;
			dfs(v1);
			cout << 7 << endl;
			D[v] += D[v1];
		}
	}
	/*for (int q = 0; q < V1[v].size(); q++) {
		ll v1 = V1[v][q];
		if (v1 == -1) {
			continue;
		}
		if (D[v1] != 0 || used[v1]) {
			continue;
		}
		cout << "v1 " << v1 << endl;
		cout << 6 << endl;
		dfs(v1);
		cout << 7 << endl;
		D[v] += D[v1];
	}*/
	// cout << v << " " << D[v] << " DP DEBUG" << endl;
}

int main() {
	ll q, w, e, a, b, c;
	// start:;
	// for (q = 0; q < 100; q++) {
	// 	D[q] = 0;
	// }
	string s;
	// pistol p1;
	// p = p1;
	n = 1e5;
	for (q = 0; q < n; q++) {
		s += char(rand() % 26 + 'a');
	}
	// cin >> s;
	// n = s.length();
	for (q = 0; q < s.length(); q++) {
		p.add(s[q] - 'a');
		// cout << "DONE " << endl << endl;
	}
	// cout << p.V.size() << endl;
	// return 0;
	// V1.resize(2 * maxn);
	// V1 = p.V;
	ll cnt = 0;
	for (q = 0; q < p.V.size(); q++) {
		for (w = 0; w < p.V[q].to.size(); w++) {
			if (p.V[q].to[w] != -1) {
		// cout << p.V[q].to.size() << endl;
				V1[q].pb(p.V[q].to[w]);
				cnt++;
				// if (cnt > 1e5) {
				// 	break;
				// }
			}
		}
	}
	cout << cnt << endl;
	cout << p.V.size() << " SZ" << endl;
	dfs(0);
	cout << "SHIT" << endl;
	// cout << "0:" << endl;
	// for (q = 0; q < maxc; q++) {
	// 	cout << p.V[0].to[q] << " ";
	// }
	// cout << endl;
	// if (D[0] - 1 == stupid(s)) {
	// 	cout << "OK" << endl;
	// 	goto start;
	// }
	// else {
	// 	cout << "NOK" << endl;
	// 	cout << s << endl;
	// }
	cout << D[0] - 1 << endl;
	// cout << stupid(s) << endl;
	return 0;
}
